from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QPushButton, QFileDialog,
    QTabWidget, QWidget, QComboBox, QMessageBox, QInputDialog
)
from pyqtgraph.exporters import ImageExporter
from pathlib import Path
import os, csv
from Backend.Services.exporter import export_clearance_plots

export_graphs_by_analysis = {
    "Extracellular": [
        "channel0_Plot", "channel1_Plot", "Spectrum",
        "Baseline Heatmap", "High_k Heatmap", "Recovery Heatmap",
        "Baseline Segment", "High K⁺ Segment", "Recovery Segment"
    ],
    "Resonance Frequency": [
        "channel0_Plot", "channel1_Plot", "zap_plot"
    ],
    "K+ Clearance": [
        "channel0_Plot", "Seg 1 - Seg 4"
    ]
}

class ExportHandler(QDialog):
    def __init__(self, result_widget=None, plot_area=None, analysis_type=None, parent=None):
        super().__init__(parent)
        self.result_widget = result_widget
        self.plot_area = plot_area
        self.analysis_type = analysis_type or "Extracellular"
        self.setWindowTitle("Export Options")
        self.setMinimumSize(400, 250)

        self.tabs = QTabWidget()
        self.tabs.addTab(self._create_export_results_tab(), "Export Results")
        self.tabs.addTab(self._create_export_graphs_tab(), "Export Graph")
        self.tabs.addTab(self._create_export_all_tab(), "Export All")

        layout = QVBoxLayout()
        layout.addWidget(self.tabs)
        self.setLayout(layout)

    def _create_export_results_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        label = QLabel("Export the Results tab contents.\nChoose to save as either TXT or CSV format.")
        label.setWordWrap(True)

        export_txt_btn = QPushButton("Export Results (.txt)")
        export_txt_btn.clicked.connect(lambda: self.export_text_results(filetype="txt"))

        export_csv_btn = QPushButton("Export Results (.csv)")
        export_csv_btn.clicked.connect(lambda: self.export_text_results(filetype="csv"))

        layout.addWidget(label)
        layout.addWidget(export_txt_btn)
        layout.addWidget(export_csv_btn)

        tab.setLayout(layout)
        return tab

    def _create_export_graphs_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()

        self.graph_selector = QComboBox()
        self.graph_selector.addItems(export_graphs_by_analysis.get(self.analysis_type, []))

        export_btn = QPushButton("Export Selected Graph")
        export_btn.clicked.connect(self.export_selected_graph)

        layout.addWidget(QLabel("Select a graph to export as PNG:"))
        layout.addWidget(self.graph_selector)
        layout.addWidget(export_btn)
        tab.setLayout(layout)
        return tab

    def _create_export_all_tab(self):
        tab = QWidget()
        layout = QVBoxLayout()
    
        label = QLabel("Export all graphs generated by the selected analysis.\n"
                       "This will save all plot images and results to the folder you choose.")
        label.setWordWrap(True)
    
        export_btn = QPushButton("Export All Generated")
        export_btn.clicked.connect(self.export_all_graphs)
    
        layout.addWidget(label)
        layout.addWidget(export_btn)
        tab.setLayout(layout)
        return tab

    def export_text_results(self, filetype="txt"):
        from collections import defaultdict
        exported_count = 0
    
        if self.result_widget:
            try:
                # Ask for layout (still via QMessageBox – this makes sense to keep)
                layout_choice = QMessageBox.question(
                    self, "Export Layout", "Export with segments vertically and metrics horizontally?",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No
                )
                segment_row_layout = layout_choice == QMessageBox.Yes
    
                # Use filetype param to determine filter and extension
                if filetype == "csv":
                    filename_filter = "CSV Files (*.csv)"
                    default_ext = ".csv"
                else:
                    filename_filter = "Text Files (*.txt)"
                    default_ext = ".txt"
    
                # Show Save File dialog
                filename, _ = QFileDialog.getSaveFileName(
                    self, "Save Results", f"results{default_ext}", filename_filter
                )
                if not filename:
                    return
    
                result_format = filetype  # now just use this instead of a prompt
    
                if result_format == "csv" and segment_row_layout:
                    segment_data = defaultdict(dict)
                    current_segment = None
    
                    for line in self.result_widget.toPlainText().splitlines():
                        line = line.strip()
                        if line.startswith("Segment"):
                            current_segment = line.replace(":", "")
                        elif ":" in line and current_segment:
                            key, value = [s.strip() for s in line.split(":", 1)]
                            segment_data[current_segment][key] = value
    
                    all_keys = set()
                    for entry in segment_data.values():
                        all_keys.update(entry.keys())
                    all_keys = sorted(all_keys)
    
                    with open(filename, "w", encoding="utf-8-sig", newline="") as f:
                        writer = csv.writer(f)
                        writer.writerow(["Segment"] + all_keys)
                        for segment, values in segment_data.items():
                            row = [segment] + [values.get(k, "") for k in all_keys]
                            writer.writerow(row)
    
                elif result_format == "csv":
                    with open(filename, "w", encoding="utf-8-sig", newline="") as f:
                        writer = csv.writer(f)
                        for line in self.result_widget.toPlainText().splitlines():
                            if ":" in line:
                                writer.writerow([s.strip() for s in line.split(":", 1)])
                            elif "\t" in line:
                                writer.writerow(line.split("\t"))
                            else:
                                writer.writerow([line])
    
                else:  # txt
                    with open(filename, "w", encoding="utf-8") as f:
                        f.write(self.result_widget.toPlainText())
    
                exported_count += 1
                QMessageBox.information(self, "Export Complete", f"Results exported to {filename}")
    
            except Exception as e:
                print(f"[ERROR] Could not save file: {e}")
                QMessageBox.critical(self, "Export Failed", f"An error occurred:\n{e}")
                
    def export_selected_graph(self):
        if not self.plot_area:
            QMessageBox.warning(self, "Error", "Plot area is missing.")
            return

        selected_name = self.graph_selector.currentText()

        if self.analysis_type == "K+ Clearance" and selected_name.startswith("Seg"):
            export_folder = QFileDialog.getExistingDirectory(self, "Select Folder to Save Segment")
            if not export_folder:
                return
            try:
                export_clearance_plots(self.plot_area, export_folder, selected_names=[selected_name])
                QMessageBox.information(self, "Export Success", f"{selected_name} exported to:\n{export_folder}")
            except Exception as e:
                QMessageBox.critical(self, "Export Failed", str(e))
            return

        widget = self._find_plot_widget_by_name(selected_name)
        if not widget or not hasattr(widget, "plotItem"):
            QMessageBox.warning(self, "Not Found", f"No graph named '{selected_name}' was found.")
            return

        filename, _ = QFileDialog.getSaveFileName(self, "Save Graph", f"{selected_name}.png", "PNG Files (*.png)")
        if filename:
            try:
                exporter = ImageExporter(widget.plotItem)
                exporter.export(filename)
                QMessageBox.information(self, "Export Success", f"Graph saved to:\n{filename}")
            except Exception as e:
                QMessageBox.critical(self, "Export Failed", str(e))

    def export_all_graphs(self):
        if not self.plot_area:
            QMessageBox.warning(self, "Error", "No plot area available.")
            return
    
        export_names = export_graphs_by_analysis.get(self.analysis_type, [])
        exported_count = 0
    
        export_folder = QFileDialog.getExistingDirectory(self, "Select Folder to Save Graphs")
        if not export_folder:
            return
    
        # Export all graph widgets (plots)
        for name in export_names:
            if self.analysis_type == "K+ Clearance" and name.startswith("Seg"):
                try:
                    export_clearance_plots(self.plot_area, export_folder, selected_names=[name])
                    exported_count += 1
                    continue
                except Exception as e:
                    print(f"[ERROR] Segment export failed: {name} - {e}")
                    continue
    
            widget = self._find_plot_widget_by_name(name)
            if not widget or not hasattr(widget, "plotItem"):
                continue
    
            try:
                exporter = ImageExporter(widget.plotItem)
                filename = os.path.join(export_folder, f"{name}.png")
                exporter.export(filename)
                exported_count += 1
            except Exception as e:
                print(f"[ERROR] Failed to export {name}: {e}")
    
        # Export results tab (CSV or TXT) with optional layout
        if self.result_widget:
            try:
                format_choice = QMessageBox.question(
                    self, "Export Format", "Export as CSV?\n(Click No for TXT)",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No
                )
                result_format = "csv" if format_choice == QMessageBox.Yes else "txt"
    
                layout_choice = QMessageBox.question(
                    self, "Export Layout", "Export with segments vertically and metrics horizontally?",
                    QMessageBox.Yes | QMessageBox.No, QMessageBox.No
                )
                segment_row_layout = layout_choice == QMessageBox.Yes
    
                filename = f"Results.{result_format}"
                result_path = os.path.join(export_folder, filename)
    
                if result_format == "csv" and segment_row_layout:
                    from collections import defaultdict
                    segment_data = defaultdict(dict)
                    current_segment = None
    
                    for line in self.result_widget.toPlainText().splitlines():
                        line = line.strip()
                        if line.startswith("Segment"):
                            current_segment = line.replace(":", "")
                        elif ":" in line and current_segment:
                            key, value = [s.strip() for s in line.split(":", 1)]
                            segment_data[current_segment][key] = value
    
                    all_keys = set()
                    for entry in segment_data.values():
                        all_keys.update(entry.keys())
                    all_keys = sorted(all_keys)
    
                    with open(result_path, "w", encoding="utf-8-sig", newline="") as f:
                        writer = csv.writer(f)
                        writer.writerow(["Segment"] + all_keys)
                        for segment, values in segment_data.items():
                            row = [segment] + [values.get(k, "") for k in all_keys]
                            writer.writerow(row)
    
                elif result_format == "csv":
                    with open(result_path, "w", encoding="utf-8-sig", newline="") as f:
                        writer = csv.writer(f)
                        for line in self.result_widget.toPlainText().splitlines():
                            if ":" in line:
                                writer.writerow([s.strip() for s in line.split(":", 1)])
                            elif "\t" in line:
                                writer.writerow(line.split("\t"))
                            else:
                                writer.writerow([line])
    
                else:
                    with open(result_path, "w", encoding="utf-8") as f:
                        f.write(self.result_widget.toPlainText())
    
                exported_count += 1
    
            except Exception as e:
                print(f"[ERROR] Could not save Results.{result_format}: {e}")

    def _find_plot_widget_by_name(self, name):
        if not self.plot_area:
            return None

        widget = getattr(self.plot_area, name, None)
        if widget and hasattr(widget, "plotItem"):
            return widget

        if hasattr(self.plot_area, "tabs"):
            for i in range(self.plot_area.tabs.count()):
                if self.plot_area.tabs.tabText(i).strip() == name:
                    tab_widget = self.plot_area.tabs.widget(i)
                    if hasattr(tab_widget, "plotItem"):
                        return tab_widget

        return None
